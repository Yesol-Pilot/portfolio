import{m as X,H as V,T as j,r as n,J as P,o as L,n as Y,k as K,e as w,K as Z,P as ee,X as te,p as ne,z as W,Y as re,Q as z}from"./index-LI-KpOx_.js";import{s as F}from"./deprecated-C8-qPaWV.js";const k=e=>e===Object(e)&&!Array.isArray(e)&&typeof e!="function";function q(e,t){const f=X(i=>i.gl),r=V(j,k(e)?Object.values(e):e);return n.useLayoutEffect(()=>{t?.(r)},[t]),n.useEffect(()=>{if("initTexture"in f){let i=[];Array.isArray(r)?i=r:r instanceof P?i=[r]:k(r)&&(i=Object.values(r)),i.forEach(p=>{p instanceof P&&f.initTexture(p)})}},[f,r]),n.useMemo(()=>{if(k(e)){const i={};let p=0;for(const A in e)i[A]=r[p++];return i}else return r},[e,r])}q.preload=e=>V.preload(j,e);q.clear=e=>V.clear(j,e);let I;const ae=new Uint8Array(16);function oe(){if(!I&&(I=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!I))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return I(ae)}const c=[];for(let e=0;e<256;++e)c.push((e+256).toString(16).slice(1));function ce(e,t=0){return c[e[t+0]]+c[e[t+1]]+c[e[t+2]]+c[e[t+3]]+"-"+c[e[t+4]]+c[e[t+5]]+"-"+c[e[t+6]]+c[e[t+7]]+"-"+c[e[t+8]]+c[e[t+9]]+"-"+c[e[t+10]]+c[e[t+11]]+c[e[t+12]]+c[e[t+13]]+c[e[t+14]]+c[e[t+15]]}const se=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),H={randomUUID:se};function ue(e,t,f){if(H.randomUUID&&!e)return H.randomUUID();e=e||{};const r=e.random||(e.rng||oe)();return r[6]=r[6]&15|64,r[8]=r[8]&63|128,ce(r)}const ie="https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png",Q=new K,S=new w,_=new z,$=new w,G=new z,T=new w,B=n.createContext(null),le=n.forwardRef(({children:e,material:t=ee,texture:f=ie,range:r,limit:d=200,frustumCulled:i,...p},A)=>{var b,E;const O=n.useMemo(()=>class extends t{constructor(){super();const l=parseInt(re.replace(/\D+/g,""))>=154?"opaque_fragment":"output_fragment";this.onBeforeCompile=y=>{y.vertexShader=`attribute float cloudOpacity;
               varying float vOpacity;
              `+y.vertexShader.replace("#include <fog_vertex>",`#include <fog_vertex>
                 vOpacity = cloudOpacity;
                `),y.fragmentShader=`varying float vOpacity;
              `+y.fragmentShader.replace(`#include <${l}>`,`#include <${l}>
                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);
                `)}}},[t]);te({CloudMaterial:O});const s=n.useRef(null),g=n.useRef([]),D=n.useMemo(()=>new Float32Array(Array.from({length:d},()=>1)),[d]),x=n.useMemo(()=>new Float32Array(Array.from({length:d},()=>[1,1,1]).flat()),[d]),h=q(f);let C=0,u=0,o;const a=new z,v=new w(0,0,1),M=new w;ne((l,y)=>{for(C=l.clock.getElapsedTime(),Q.copy(s.current.matrixWorld).invert(),l.camera.matrixWorld.decompose($,G,T),u=0;u<g.current.length;u++)o=g.current[u],o.ref.current.matrixWorld.decompose(S,_,T),S.add(M.copy(o.position).applyQuaternion(_).multiply(T)),_.copy(G).multiply(a.setFromAxisAngle(v,o.rotation+=y*o.rotationFactor)),T.multiplyScalar(o.volume+(1+Math.sin(C*o.density*o.speed))/2*o.growth),o.matrix.compose(S,_,T).premultiply(Q),o.dist=S.distanceTo($);for(g.current.sort((R,N)=>N.dist-R.dist),u=0;u<g.current.length;u++)o=g.current[u],D[u]=o.opacity*(o.dist<o.fade-1?o.dist/o.fade:1),s.current.setMatrixAt(u,o.matrix),s.current.setColorAt(u,o.color);s.current.geometry.attributes.cloudOpacity.needsUpdate=!0,s.current.instanceMatrix.needsUpdate=!0,s.current.instanceColor&&(s.current.instanceColor.needsUpdate=!0)}),n.useLayoutEffect(()=>{const l=Math.min(d,r!==void 0?r:d,g.current.length);s.current.count=l,F(s.current.instanceMatrix,{offset:0,count:l*16}),s.current.instanceColor&&F(s.current.instanceColor,{offset:0,count:l*3}),F(s.current.geometry.attributes.cloudOpacity,{offset:0,count:l})});let m=[(b=h.image.width)!==null&&b!==void 0?b:1,(E=h.image.height)!==null&&E!==void 0?E:1];const U=Math.max(m[0],m[1]);return m=[m[0]/U,m[1]/U],n.createElement("group",L({ref:A},p),n.createElement(B.Provider,{value:g},e,n.createElement("instancedMesh",{matrixAutoUpdate:!1,ref:s,args:[null,null,d],frustumCulled:i},n.createElement("instancedBufferAttribute",{usage:W,attach:"instanceColor",args:[x,3]}),n.createElement("planeGeometry",{args:[...m]},n.createElement("instancedBufferAttribute",{usage:W,attach:"attributes-cloudOpacity",args:[D,1]})),n.createElement("cloudMaterial",{key:t.name,map:h,transparent:!0,depthWrite:!1}))))}),J=n.forwardRef(({opacity:e=1,speed:t=0,bounds:f=[5,1,1],segments:r=20,color:d="#ffffff",fade:i=10,volume:p=6,smallestVolume:A=.25,distribute:b=null,growth:E=4,concentrate:O="inside",seed:s=Math.random(),...g},D)=>{function x(){const a=Math.sin(s++)*1e4;return a-Math.floor(a)}const h=n.useContext(B),C=n.useRef(null),[u]=n.useState(()=>ue()),o=n.useMemo(()=>[...new Array(r)].map((a,v)=>({segments:r,bounds:new w(1,1,1),position:new w,uuid:u,index:v,ref:C,dist:0,matrix:new K,color:new Y,rotation:v*(Math.PI/r)})),[r,u]);return n.useLayoutEffect(()=>{o.forEach((a,v)=>{Z(a,{volume:p,color:d,speed:t,growth:E,opacity:e,fade:i,bounds:f,density:Math.max(.5,x()),rotationFactor:Math.max(.2,.5*x())*t});const M=b?.(a,v);if(M||r>1){var m;a.position.copy(a.bounds).multiply((m=M?.point)!==null&&m!==void 0?m:{x:x()*2-1,y:x()*2-1,z:x()*2-1})}const U=Math.abs(a.position.x),l=Math.abs(a.position.y),y=Math.abs(a.position.z),R=Math.max(U,l,y);a.length=1,U===R&&(a.length-=U/a.bounds.x),l===R&&(a.length-=l/a.bounds.y),y===R&&(a.length-=y/a.bounds.z),a.volume=(M?.volume!==void 0?M.volume:Math.max(Math.max(0,A),O==="random"?x():O==="inside"?a.length:1-a.length))*p})},[O,f,i,d,e,E,p,s,r,t]),n.useLayoutEffect(()=>{const a=o;return h.current=[...h.current,...a],()=>{h.current=h.current.filter(v=>v.uuid!==u)}},[o]),n.useImperativeHandle(D,()=>C.current,[]),n.createElement("group",L({ref:C},g))}),pe=n.forwardRef((e,t)=>n.useContext(B)?n.createElement(J,L({ref:t},e)):n.createElement(le,null,n.createElement(J,L({ref:t},e))));export{pe as C};
